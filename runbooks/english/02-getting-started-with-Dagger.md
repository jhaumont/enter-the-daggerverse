# Getting started with Dagger

The goal is to build components' of CI pipeline for an application called `hello` (allow to run `hello <something in the way>`) with a Dagger's module.

## Init Dagger's module

> [!NOTE]
> If you use local installation of Dagger, please fork coldelab's repository on your computer:
> ```bash
> git clone https://github.com/<votre-pseudo-github>/Enter-the-Daggerverse.git
> ```

Now, open folder called `hello`:
```bash
cd hello
```

> [!IMPORTANT]
> All follow commands are run in `hello` folder from your terminal.

Init your Dagger's module:
```bash
dagger init --sdk=go --source=./dagger
```

This command will be download Docker's image of Dagger engine then start it and generate skeleton of your Dagger's module:
- a `dagger.json` file that contains metadata,
- a `dagger` folder: 
  - a `main.go` file that will contains your module's code,
  - a `dagger.gen.go` file and a `internal` folder that contains utily code generated by Dagger,

In the `dagger/main.go` file, replace the existing code with the one below:

```go
package main

import (
	"context"
	"dagger/hello/internal/dagger"
	"fmt"
	"math"
	"math/rand/v2"
)

type Hello struct {
}

// Publish the application container after building and testing it on-the-fly
func (m *Hello) Publish(ctx context.Context, source *dagger.Directory) (string, error) {
	return m.Build(source).
		Publish(ctx, fmt.Sprintf("ttl.sh/hello-%.0f", math.Floor(rand.Float64()*10000000))) //#nosec
}

// Build the application container
func (m *Hello) Build(source *dagger.Directory) *dagger.Container {
	build := m.BuildEnv(source).
		WithExec([]string{"go", "build", "-o", "bin/"}).
		Directory("./bin")
	return dag.Container().From("debian:bookworm-slim").
		WithDirectory("/usr/bin/", build).
		WithExposedPort(666).
		WithDefaultArgs([]string{"/usr/bin/hello"})
}

// Build a ready-to-use development environment
func (m *Hello) BuildEnv(source *dagger.Directory) *dagger.Container {
return dag.Container().
	From("golang:1.23-alpine").
	WithDirectory("/src", source).
	WithWorkdir("/src").
	WithEnvVariable("CGO_ENABLED", "0")
}
```

> [!NOTE]
> The module has now 3 functions:
> - `BuildEnv` to build an environnement (Docker image) to be use by another function,
> - `Build` to compile the web application,
> - `Publish` to publish your application's Docker image on `ttl.sh` registry.

> [!NOTE]
> `ttl.sh` is an amazing public Docker repository to store Docker image temporarily. Caution, this repository is public, don't publish any critical images.

> [!WARNING]
> The `dagger.gen.go` has compilation issue.
> 
> When we change content of `dagger/main.go` file, public interface change.
> 
> We must regenerate Dagger's module's code with command:
> ```bash
> dagger develop
> ```

## Build environment for application's CI's pipeline

> [!NOTE]
> For public method, the **Go** language use `PascalCase`. That mean, every word start by uppercase. In our example, we have `BuildEnv` public method.
>
> However, to call `BuildEnv` public method from command line, the name of method is converted by using `kebab-case`. The name will be `build-env`.
>
> Read example bellow.

Now that we have a module, we will run one of its functions:
```bash
dagger call build-env --source=.
```

On the terminal, we will see **interactives** traces.
Try to play with traces.
For example, you can increase verbosity during execution by pressing `+` key.

> [!NOTE]
> All traces & spans that you can read are OpenTelemetry, like HTTP request.
> First times, you can be disturbed by OpenTelemetry and also, it is strongest link to Docker.
> But, after somes time, you will be find with this great feature.

At the end of command execution, you will see this message:
![](../dagger-cloud-traces.png)

By default, Dagger try to send all traces in Dagger cloud. If you don't want this behavior, you can disable it by setting environment variables called `NOTHANKS`, `SHUTUP`, `GOAWAY` or `STOPIT`:

```bash
export STOPIT=1
dagger call build-env --source=.
```

Now, message disappeared.

You find this strange? You right, it's just a funny stuff done by Solomon Hykes in [dagql/idtui/frontend.go](https://github.com/dagger/dagger/commit/6238db7a484daa6e4ad14032a9dce23cbc280643#diff-f5226e94ea6152ddc0519aecff9194c2f24160f2b52e35be6affabd761b73a27R28):
```
// having a bit of fun with these. cc @vito @jedevc
var skipLoggedOutTraceMsgEnvs = []string{"NOTHANKS", "SHUTUP", "GOAWAY", "STOPIT"}
```

Now you have a **Go** execution environment with all source of your project.

## Dagger cloud

To be more confortable for this codelab, we are going to use **Dagger cloud**.

Please, enable traces by removing environment variable:
```bash
unset STOPIT
```

To see traces, you must create an account (it's free) on [Dagger cloud](https://docs.dagger.io/manuals/user/cloud-get-started).

> [!TIP]
> For this codelab, the easiest way to create an account on **Dagger cloud** is to use `Sign in with GitHub` button.

At loggin, create `devfest` organization.
A token will be given, export it in you terminal:

```bash
export DAGGER_CLOUD_TOKEN=<token>
```

You can add this to your `.profile` (or anything else) to avoid do it every time.

## Interact with the result of your function

When your function return a Docker's image, you can interact with it to inspect its content for example.

Run again `build-env` function with `terminal` command:
```bash
dagger call build-env --source=. terminal --cmd=sh
```

> [!WARNING]
> Use an image with a shell in it (sh, bash, etc)

Check that project's folder is mounted in the container:
```bash
ls -al
```

Type `exit` to leave terminal from container.

At the end of execution, a link to **Dagger cloud** is displayed.
Click on this to explore traces of your command.

## Build application

Now, we have a **Go** environment, we can build application.

Run command below:
```bash
dagger call build --source=.
```

The application was built and the Docker's image too!
The output/result of the function is a ready to use Docker image!

Restart build to interact with the container:
```bash
dagger call build --source=. terminal --cmd=sh
```

> [!NOTE]
> But, wait a minute! Where `terminal` command come from? I can't find it with `dagger --help`?
>
> It's a good question. You can find it when you read the [User Manual](https://docs.dagger.io/manuals/user/terminal)

Please check that the binary of application is here:
```bash
ls -al /bin/hello
```

Type `exit` to leave container's terminal.

## Test application

Now that application Docker's image is built, run it and test it on our computer!

Start the application with `as-service` Dagger command:
```bash
dagger call build --source=. as-service up --ports=8080:666
```

Click on popup button in VSCode and add `/devfest` at the end.

> [!NOTE]
> If you don't use codespace, open your internet browser and enter this URL `localhost:8080/devfest`.

> [!NOTE]
> But, wait a minute! Where `as-service` command come from? I can't find it with `dagger --help`?
>
> It's a good question. You can find it when you read the [User Manual](https://docs.dagger.io/api/chaining/#start-containers-as-services)

## Publish application

The last step is to publish our application on the `ttl.sh` registry:
```bash
dagger call publish --source=.
```

Test our published's image (`ID` is the uniq id of image):
```bash
docker run --rm --detach --publish 8080:666 ttl.sh/hello-<ID>
```

In the `PORTS` tab, next to `TERMINAL` tab, add `8080` port.


Click on the associated link, and add `/devfest` at the end of url.

> [!NOTE]
> If you don't use codespace, open your internet browser and enter this URL `localhost:8080/devfest`.

Now, you have some usables functions to build your CI pipeline with any CI/CD engine.

Next, you will use an external Dagger's module in the functions. Please go to the next chapter [Use module from Daggervers](03-use-module-from-daggerverse.md).

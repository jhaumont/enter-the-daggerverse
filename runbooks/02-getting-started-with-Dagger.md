# Getting started with Dagger

The goal is to build components' of CI pipeline for an application called `hello` (allow to run `hello <something in the way>`) with a Dagger's module.

## Init Dagger's module

> [!NOTE]
> If you use local installation of Dagger, please fork coldelab's repository on your computer:
> ```bash
> git clone https://github.com/<votre-pseudo-github>/Enter-the-Daggerverse.git
> ```

Now, open folder called `hello`:
```bash
cd hello
```

> [!IMPORTANT]
> All follow commands are run in `hello` folder from your terminal.

Init your Dagger's module:
```bash
dagger init --sdk=go --source=./dagger
```

This command will be download Docker's image of Dagger engine then start it and generate skeleton of your Dagger's module:
- a `dagger.json` file that contains metadatas,
- a `dagger` folder: 
  - a `main.go` file that will contains your module's code,
  - a `dagger.gen.go` file and a `internal` folder that contains utily code generated by Dagger,

Dans le fichier `dagger/main.go`, remplacez le code existant par celui ci-dessous :

```go
package main

import (
	"context"
	"dagger/hello/internal/dagger"
	"fmt"
	"math"
	"math/rand/v2"
)

type Hello struct {
}

// Publish the application container after building and testing it on-the-fly
func (m *Hello) Publish(ctx context.Context, source *dagger.Directory) (string, error) {
	return m.Build(source).
		Publish(ctx, fmt.Sprintf("ttl.sh/hello-%.0f", math.Floor(rand.Float64()*10000000))) //#nosec
}

// Build the application container
func (m *Hello) Build(source *dagger.Directory) *dagger.Container {
	build := m.BuildEnv(source).
		WithExec([]string{"go", "build", "-o", "bin/"}).
		Directory("./bin")
	return dag.Container().From("debian:bookworm-slim").
		WithDirectory("/usr/bin/", build).
		WithExposedPort(666).
		WithEntrypoint([]string{"/usr/bin/hello"})
}

// Build a ready-to-use development environment
func (m *Hello) BuildEnv(source *dagger.Directory) *dagger.Container {
return dag.Container().
	From("golang:1.23-alpine").
	WithDirectory("/src", source).
	WithWorkdir("/src").
	WithEnvVariable("CGO_ENABLED", "0")
}
```

> [!NOTE]
> The module has now 3 functions:
> - `BuildEnv` to build an environnement (Docker image) to be use by another function,
> - `Build` to be compile the web application,
> - `Publish` to publish your application's Docker image on `ttl.sh` registry.

> [!NOTE]
> `ttl.sh` is amazing public Docker repository to store Docker image temporarly. Caution, this repository is public, don't publish any critical image.

> [!WARNING]
> The `dagger.gen.go` has compilation issue.
> 
> When we change content of `dagger/main.go` file, public interface change.
> 
> We must regenerate Dagger's module's code with command:
> ```bash
> dagger develop
> ```

## Build environment for application's CI's pipeline

> [!NOTE]
> For public method, the **Go** language use `PascalCase`. That mean, every word start by uppercase. In our example, we have `BuildEnv` public method.
>
> However, to call `BuildEnv` public method form command line, the name of method is converted by using `kebab-case`. The name will be `build-env`.
>
> Read example bellow.

Now that we have a module, we will run one of his functions:
```bash
dagger call build-env --source=.
```

On the terminal, we will see an **interactives** traces.
Try to play with traces.
For example, you can increase verbosity during execution by pressing `+` key.

> [!NOTE]
> All traces & spans that you can read are OpenTelemetry, like HTTP request.
> First times, you can be disturbed by OpenTelemetry cause it is strongest link to Docker.
> But, after somes time, you will be find it's great feature.

At the end of execution of command, you will be see this message:
![](dagger-cloud-traces.png)

By default, Dagger try to send all traces in Dagger cloud. If you don't want this behavior, you can disable by setting environment variables called 
`NOTHANKS`, `SHUTUP`, `GOAWAY` or `STOPIT`:

```bash
export STOPIT=1
dagger call build-env --source=.
```

Now, message disapear.

You find this strange? You right, it's just a funny stuff by Solomon Hykes in [dagql/idtui/frontend.go](https://github.com/dagger/dagger/commit/6238db7a484daa6e4ad14032a9dce23cbc280643#diff-f5226e94ea6152ddc0519aecff9194c2f24160f2b52e35be6affabd761b73a27R28):
```
// having a bit of fun with these. cc @vito @jedevc
var skipLoggedOutTraceMsgEnvs = []string{"NOTHANKS", "SHUTUP", "GOAWAY", "STOPIT"}
```

Now you have a **Go** execution environment with all source of your project.

## Dagger cloud

To be more confortable for this codelab, we will use **Dagger cloud**.

Please, enable trace sending by remove environment variable:
```bash
unset STOPIT=1
```

To see traces, you must create an account (it's free) on [Dagger cloud](https://docs.dagger.io/manuals/user/cloud-get-started).

> [!TIP]
> In case of this codelab, the more easy way to create an account on **Dagger cloud** is by using  `Sign in with GitHub` button.

At loggin, create `devfest` organization.
A token will be given, export it in you terminal:

```bash
export DAGGER_CLOUD_TOKEN=<token>
```

You can add this to your `.profile` to avoid do this at each time.

## Interact with the result of your function

When your function return a Docker's image, you can interect with it, for example, to inspect its content.

Run again `build-env` function with `terminal` command:
```bash
dagger call build-env --source=. terminal --cmd=sh
```

> [!WARNING]
> Select an image with shell (sh, bash, etc)

Check that project's folder are mounted in container:
```bash
ls -al
```

Enter `exit` to leave terminal from container.

At the end of execution, a link to  **Dagger cloud** is displayed.
Click on this to explore traces of your command.

## Build application

Now, we have a **Go** environment, we can build application.

Run command below:
```bash
dagger call build --source=.
```

The application was build and a Docker's image also!
The output/result of function is a Docker image ready to use!

Restart build to interact with container:
```bash
dagger call build --source=. terminal --cmd=sh
```

> [!NOTE]
> But, wait a minute! Where `terminal` command come from? I don't find it with `dagger --help`?
>
> It's a good question. You can find it when you read the [User Manual](https://docs.dagger.io/manuals/user/terminal)

Please check that the binary of application is here:
```bash
ls -al /bin/hello
```

Enter `exit` to leave terminal from container.

## Test the application

Now that Docker's image of application is build, run it and test if on our computer!

Start the application with `as-service` command of Dagger :
```bash
dagger call build --source=. as-service up --ports=8080:666
```

Click on popup button from VSCode and add at end `/devfest`.

> [!NOTE]
> if you don't use codespace, open your internet browser and enter this URL `localhost:8080/devfest`.

> [!NOTE]
> But, wait a minute! Where `as-service` command come from? I don't find it with `dagger --help`?
>
> It's a good question. You can find it when you read the [User Manual](https://docs.dagger.io/manuals/user/terminal)

## Publish application

The last step is to publish our application on the `ttl.sh` registry:
```bash
dagger call publish --source=.
```

Test our published's image (ID is the uniq id of image):
```bash
docker run --rm --detach --publish 8080:666 ttl.sh/hello-<ID>
```

In the `PORTS` tab, newt to `TERMINAL` tab, add `8080` port.


Click on the associate link, and add `/devfest` at the end of url of page.

> [!NOTE]
> If you don't use codespace, open your internet browser and enter the URL `localhost:8080/devfest`.

Now, you have some usables functions to build your CI pipeline with any CI engine.

To the next, you will use an external Dagger's module in function. Please go to the next page [Use module from Daggervers](03-use-module-from-daggerverse.md).
